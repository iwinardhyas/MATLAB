% 1. Setup CasADi
addpath('/home/zee/Erwin/MATLAB/casadi-3.7.1-linux64-matlab2018b');
% addpath('C:\Users\DELL\Documents\MATLAB\casadi-3.7.0-windows64-matlab2018b');
import casadi.*

% Clear workspace to avoid variable conflicts
clear variables
clear x u
clc

%% 2. Definisikan Parameter Sistem
m = 0.5;    % Massa (kg)
g = 9.81;   % Gravitasi (m/s^2)
l = 0.25;   % Panjang lengan (m)
Ixx = 4.85e-3; % Momen inersia
Iyy = 4.85e-3;
Izz = 8.81e-3;

% Pastikan semua parameter adalah scalar numeric
assert(isnumeric(m) && isscalar(m), 'Mass m must be numeric scalar');
assert(isnumeric(g) && isscalar(g), 'Gravity g must be numeric scalar');

% Dimensi State dan Input
nx = 12; % [x,y,z,phi,theta,psi,vx_inertial,vy_inertial,vz_inertial,p,q,r]
nu = 4;  % [f1, f2, f3, f4]

M = 1;
% Horizon Prediksi NMPC
N = 5; % Kurangi horizon untuk konvergensi lebih baik
dt = 0.1; % Time step lebih kecil
dt_sub = dt / M;  % pastikan M sudah didefinisikan

% Hovering thrust per motor (pastikan numeric)
thrust_hover_value = double(m * g / 4);  % Force as double
fprintf('Hover thrust per motor: %.3f N\n', thrust_hover_value);

%% 3. Definisikan Model Dinamika Quadrotor yang Konsisten
% Input simbolik
x = MX.sym('x', nx, 1); % State
u = MX.sym('u', nu, 1); % Input (gaya dorong motor)

% Ekstrak state
px = x(1); py = x(2); pz = x(3);
phi = x(4); theta = x(5); psi = x(6);
vx_inertial = x(7); vy_inertial = x(8); vz_inertial = x(9);
p = x(10); q = x(11); r = x(12);

% Konversi thrust motor ke total force dan torque
F_total = sum(u);
tau_phi = l * (u(2) - u(4));
tau_theta = l * (u(3) - u(1));
tau_psi = 0.005 * (-u(1) + u(2) - u(3) + u(4));

% Rotation matrices
R_b_i = rotz(psi) * roty(theta) * rotx(phi);

% Thrust dalam body frame (mengarah ke atas)
thrust_body = [0; 0; F_total];
% Transform ke inertial frame
thrust_inertial = R_b_i * thrust_body;

% Percepatan dalam inertial frame
ax_inertial = thrust_inertial(1) / m;
ay_inertial = thrust_inertial(2) / m;
az_inertial = thrust_inertial(3) / m - g;

% Persamaan Euler untuk angular acceleration
p_dot = (tau_phi + (Iyy - Izz) * q * r) / Ixx;
q_dot = (tau_theta + (Izz - Ixx) * p * r) / Iyy;
r_dot = (tau_psi + (Ixx - Iyy) * p * q) / Izz;

% Kinematic equations untuk orientasi
phi_dot = p + q*sin(phi)*tan(theta) + r*cos(phi)*tan(theta);
theta_dot = q*cos(phi) - r*sin(phi);
psi_dot = q*sin(phi)/cos(theta) + r*cos(phi)/cos(theta);

% State derivative
xdot = [vx_inertial; vy_inertial; vz_inertial; ... % Position rates
        phi_dot; theta_dot; psi_dot; ... % Orientation rates
        ax_inertial; ay_inertial; az_inertial; ... % Velocity rates (inertial)
        p_dot; q_dot; r_dot]; % Angular velocity rates

% Fungsi dinamika
f = Function('f', {x, u}, {xdot});

% Diskretisasi RK4
X = MX.sym('X', nx, 1);
U = MX.sym('U', nu, 1);
XDOT = f(X, U);
k1 = XDOT;
k2 = f(X + dt/2*k1, U);
k3 = f(X + dt/2*k2, U);
k4 = f(X + dt*k3, U);
X_next = X + dt/6*(k1 + 2*k2 + 2*k3 + k4);
F_discrete = Function('F_discrete', {X, U}, {X_next});

x_next_sub = X + dt_sub/6 * (k1 + 2*k2 + 2*k3 + k4);
F_sub = Function('F_sub', {X, U}, {x_next_sub});

%% 4. Setup NMPC Problem
w = {};
J = 0;
g = {};
lbw = []; ubw = []; w0 = [];
lbg = []; ubg = [];

X_vars = cell(N+1, 1);
U_vars = cell(N, 1);
X_sub_vars = cell(N, M-1);  % State intermediate dalam interval multiple shooting

% Parameter vector: [current_state; reference_state]
n_params = nx + nx*(N+1);  % [x0; xref_0; xref_1; ... xref_N]
all_params_sym = MX.sym('all_params', n_params, 1);
X_initial_param = all_params_sym(1:nx);
X_ref_param = all_params_sym(nx+1:end);  % Hasil MX, bukan cell
X_ref_params = cell(N+1, 1);
for k = 0:N
    start_idx = nx + nx*k + 1;
    end_idx = nx + nx*(k+1);
    X_ref_params{k+1} = all_params_sym(start_idx:end_idx);
end

% Initial state variable
X_vars{1} = MX.sym('X_0', nx, 1);
w = {w{:}, X_vars{1}};
lbw = [lbw; -inf*ones(nx,1)];
ubw = [ubw; inf*ones(nx,1)];
% w0 = [w0; zeros(nx,1)];

% Initial state constraint
g = {g{:}, X_vars{1} - X_initial_param};
lbg = [lbg; zeros(nx,1)];
ubg = [ubg; zeros(nx,1)];

% --- Generate warm start untuk propagasi awal ---
arg_w0 = [];
% x_guess = zeros(nx,1); 
x_guess = QuadrotorReferenceTrajectory6(0);

% 1. Initial state
arg_w0 = [arg_w0; x_guess];

% 2. Loop sepanjang horizon
for k = 1:N
    % Control guess (hover)
    arg_w0 = [arg_w0; thrust_hover_value*ones(nu,1)];
    
    % Intermediate states (multiple shooting)
    for m = 1:M-1
        arg_w0 = [arg_w0; x_guess];  % bisa pakai interpolasi jika mau
    end
    
    % Next state guess
    arg_w0 = [arg_w0; x_guess];
end


% Main horizon loop
for k = 0:N-1
    % Control variables
    U_vars{k+1} = MX.sym(['U_' num2str(k)], nu, 1);
    w = {w{:}, U_vars{k+1}};
    lbw = [lbw; 0.2*thrust_hover_value*ones(nu,1)]; % Min 10% hover thrust
    ubw = [ubw; 3.0*thrust_hover_value*ones(nu,1)];   % Max 300% hover thrust
    arg_w0 = [arg_w0; thrust_hover_value*ones(nu,1)]; % Initialize at hover
    
    % Multiple Shooting Integration
    X_current = X_vars{k+1};
    for m = 1:M-1
        % Intermediate state
        X_sub_vars{k+1, m} = MX.sym(['X_' num2str(k) '_sub_' num2str(m)], nx, 1);
        w = {w{:}, X_sub_vars{k+1, m}};
        lbw = [lbw; -inf*ones(nx,1)];
        ubw = [ubw;  inf*ones(nx,1)];
        
        % Warm start dari propagasi dinamika
        x_guess = full(F_sub(x_guess, thrust_hover_value*ones(nu,1)));
        arg_w0 = [arg_w0; x_guess];
        
        % Constraint: integrasi sub-step
        X_predicted = F_sub(X_current, U_vars{k+1});
        g = {g{:}, X_predicted - X_sub_vars{k+1, m}};
        lbg = [lbg; zeros(nx,1)];
        ubg = [ubg; zeros(nx,1)];
        
        % Update state untuk sub-step berikutnya
        X_current = X_sub_vars{k+1, m};
    end
    
    % Next state variables
    X_vars{k+2} = MX.sym(['X_' num2str(k+1)], nx, 1);
    w = {w{:}, X_vars{k+2}};
    lbw = [lbw; -inf*ones(nx,1)];
    ubw = [ubw; inf*ones(nx,1)];
%     w0 = [w0; zeros(nx,1)];
    x_guess = full(F_discrete(x_guess, thrust_hover_value*ones(nu,1)));
    arg_w0 = [arg_w0; x_guess];
    
      % Constraint: integrasi akhir interval
    X_predicted_final = F_sub(X_current, U_vars{k+1});
    g = {g{:}, X_predicted_final - X_vars{k+2}};
    lbg = [lbg; zeros(nx,1)];
    ubg = [ubg; zeros(nx,1)];
    
    % Cost function - CONSERVATIVE tuning untuk stabilitas
    % Position tracking dengan weight yang reasonable
    Q = diag([10, 100, 150, ... % px, py, pz
                   1, 10, 10, ...   % phi, theta, psi
                   1, 1, 1, ...      % vx, vy, vz
                   1, 1, 1]);  % p, q, r
    R = diag([1, 1, 1, 1]); % Bobot upaya kontrol
    
    J = J + (X_vars{k+1} - X_ref_params{k+1})' * Q * (X_vars{k+1} - X_ref_params{k+1}) + ...
            U_vars{k+1}' * R * U_vars{k+1};

      
    for m = 1:M-1
        Q_sub = 0.1 * Q;
        alpha = m / M;
        X_ref_interp = (1-alpha) * X_ref_params{k+1} + alpha * X_ref_params{k+2};
        J = J + (X_sub_vars{k+1, m} - X_ref_interp)' * Q_sub * (X_sub_vars{k+1, m} - X_ref_interp);
    end
    
    % Input rate penalty
    if k > 0
%         R_rate = 0.1 * eye(nu);
        tracking_error = norm(X_vars{k+1}(1:3) - X_ref_params{k+1}(1:3)); % error posisi (x,y,z)
        adapt_factor = 1 + tracking_error;  % semakin besar error, semakin longgar
        R_rate = (0.1 / adapt_factor) * eye(nu);
%         R_rate = rate_penalty_param * eye(nu);

        J = J + (U_vars{k+1} - U_vars{k})' * R_rate * (U_vars{k+1} - U_vars{k});
    end

end

% Terminal cost
Qf = 3 * Q; % Higher terminal weight
J = J + (X_vars{N+1} - X_ref_params{N+1})' * Qf * (X_vars{N+1} - X_ref_params{N+1});


% NLP problem
nlp = struct('f', J, 'x', vertcat(w{:}), 'g', vertcat(g{:}), 'p', all_params_sym);

% Solver options - lebih konservatif untuk stabilitas
solver_options = struct;
solver_options.print_time = false;
solver_options.ipopt.max_iter = 5;
solver_options.ipopt.tol = 1e-2;
solver_options.ipopt.acceptable_tol = 1e-1;
solver_options.ipopt.linear_solver = 'mumps';
solver_options.ipopt.hessian_approximation = 'exact';
solver_options.ipopt.print_level = 0;
solver_options.ipopt.mu_strategy = 'adaptive';

solver = nlpsol('solver', 'ipopt', nlp, solver_options);
% solver.generate('nmpc_solver.c');
% mex nmpc_solver.c -largeArrayDims -lipopt -lmumps

%% 5. Simulation Loop
T_sim = 20;
N_sim = T_sim / dt;
history_x = zeros(nx, N_sim + 1);
history_u = zeros(nu, N_sim);
history_x_ref = zeros(nx, N_sim + 1);
v_ref_history = zeros(3,N_sim);

% Initial state: start closer to first reference point
x_ref_initial = QuadrotorReferenceTrajectory6(0);
current_state = zeros(nx, 1);
current_state(1:3) = x_ref_initial(1:3); % Start at reference position
current_state(3) = max(current_state(3), 0.0); % Ensure minimum altitude
history_x(:, 1) = current_state;

%% ---------- APF parameters (set di awal, sebelum loop) ----------
k_att = 1.2;       % attractive gain
k_rep = 2.0;       % repulsive gain (tune)
d0    = 3.0;       % influence distance of obstacles [m]
v_scale = 0.9;     % scale factor to convert F_total -> v_ref (m/s per N-equivalent)
max_v_ref = 1.0;   % maximum lin velocity commanded by APF [m/s]

obs_center = [ 3  ;  7  ; 1.0 ];  % obstacle 1 di (3,7,1)
obs_radius = 1.0;                 % radius 1m

% kalau lebih dari 1 obstacle:
obs_center = [3  6  8 ;    % x
              7  2  5 ;    % y
              1  1  2 ];   % z
obs_radius = [1.0  0.8  1.5];   % radius masing-masing obstacle

%%
fprintf('Starting NMPC simulation...\n');
fprintf('Initial state: [%.3f, %.3f, %.3f]\n', current_state(1:3)');

for i = 1:N_sim
    
    current_time = (i-1) * dt;
    % Get reference trajectory
    x_ref_at_current_time = QuadrotorReferenceTrajectory6(current_time);
    history_x_ref(:, i) = x_ref_at_current_time;
    
    %%APF
    p = current_state(1:3);  % drone position
    F_att = -k_att * (p - x_ref_at_current_time(1:3));  % goal_pos global target (3x1)
    
    F_rep = zeros(3,1);
    num_obs = size(obs_center,2);
    for j = 1:num_obs
        c = obs_center(:,j);
        r = obs_radius(j);
        vec = p - c;
        dist = norm(vec);
        d = dist - r;  % distance to obstacle surface
        if d <= 0
            % already inside obstacle -> strong repulsion (clamp to avoid NaN)
            dir_ = vec / (dist + 1e-6);
%         if dist < 1e-6
%             % Avoid division by zero - push in random direction
%             dir_ = [1; 0; 0];  % or use previous direction
%         else
%             dir_ = vec / dist;  % direction AWAY from obstacle center
%         end
            F_rep = F_rep + k_rep * 1e3 * dir_;
            status = '!!! MENABRAK !!!';
        elseif d < d0
            dir_ = vec / dist;
            % standard repulsive magnitude
            mag = k_rep * (1/d - 1/d0) * (1/d^2) * (d/norm(d));
%             mag = k_rep * (1/d^2);
            F_rep = F_rep + mag * dir_;
            status = 'Dekat (zona repulsif)';
        else
            status = 'Aman (di luar zona repulsif)';
        end
        fprintf('Waktu %.2f s | Obstacle %d | Jarak permukaan d = %.2f m | Status: %s\n', ...
        i*dt, j, d, status);
    end
    F_total = F_att + F_rep;
    v_ref_local = v_scale * F_total;
    % limit magnitude
    vn = norm(v_ref_local);
    if vn > max_v_ref
        v_ref_local = v_ref_local / vn * max_v_ref;
    end
    % optionally smooth v_ref over time (low-pass)
    if exist('prev_v_ref','var')
        alpha_lp = 0.4; % low-pass factor (0..1), tune
        v_ref = alpha_lp * prev_v_ref + (1-alpha_lp) * v_ref_local;
    else
        v_ref = v_ref_local;
    end
    prev_v_ref = v_ref;
    v_ref_history(:,i)=v_ref; 
%     fprintf('Waktu: %.2f s, Jarak ke Rintangan (d): %.2f m, Magnitudo v_ref: %.2f m/s\n', i, d, vn);
    fprintf('Waktu %.2f s | v_ref = [%.2f, %.2f, %.2f] | Magnitudo = %.2f m/s\n\n | Jarak ke Rintangan (d): %.2f m | F_att: %.2f | F_rep: %.2f ', ...
    i*dt, v_ref(1), v_ref(2), v_ref(3), vn, d,F_att,);
    %%

    
    % Build parameter vector
    X_ref_horizon = generate_reference_horizon(current_time, N, dt, @QuadrotorReferenceTrajectory6);
    
    %%
    for kk = 1:(N+1)
        % shift only the position rows (1:3)
%         X_ref_horizon(1:3,kk) = X_ref_horizon(1:3,kk) + v_ref * (kk-1) * dt;
        % optionally reduce shift weighting for farther horizon steps (fade-out)
        weight = exp(-0.1*(kk-1)); 
        X_ref_horizon(1:3,kk) = X_ref_horizon(1:3,kk) + weight * v_ref * (kk-1)*dt;
    end
    %%
    actual_params = [current_state; reshape(X_ref_horizon, [], 1)];
    
    % Solve NMPC
    try
%         tic;
        sol = solver('x0', arg_w0, 'lbx', lbw, 'ubx', ubw, ...
                     'lbg', lbg, 'ubg', ubg, 'p', actual_params);
%         solver_time = toc; % catat waktu solver
%         fprintf('Step %d: Solver time = %.4f s (dt = %.4f s)\n', i, solver_time, dt);
%         solver_times(i) = solver_time;
        
        % Extract optimal control
        opt_w = full(sol.x);
        u_optimal = opt_w(nx + 1 : nx + nu);
        
        % Check solver status (compatible with different CasADi versions)
        try
            if isfield(sol, 'stats') && isfield(sol.stats, 'return_status')
                status = char(sol.stats.return_status);
                if ~strcmp(status, 'Solve_Succeeded')
                    fprintf('Warning: Solver status at step %d: %s\n', i, status);
                end
            end
        catch
            % Ignore status check if not available
        end
        
    catch ME
        fprintf('Solver failed at step %d: %s\n', i, ME.message);
        % Use hover thrust as fallback
        u_optimal = thrust_hover_value * ones(nu, 1);
        opt_w = arg_w0; % Keep previous solution for warm start
    end
    
    history_u(:, i) = u_optimal;
    
    % Simulate system forward
    current_state = full(F_discrete(current_state, u_optimal));
    history_x(:, i+1) = current_state;
    
    % Update warm start
    arg_w0 = shift_solution(opt_w, nx, nu, N, M);
    
    % Progress display with error analysis
%     if mod(i, 20) == 0
%         pos_error = norm(current_state(1:3) - x_ref_at_current_time(1:3));
%         fprintf('Step %d/%d, Pos: [%.2f, %.2f, %.2f], Ref: [%.2f, %.2f, %.2f], Error: %.2f\n', ...
%                 i, N_sim, current_state(1), current_state(2), current_state(3), ...
%                 x_ref_at_current_time(1), x_ref_at_current_time(2), x_ref_at_current_time(3), pos_error);
%         fprintf('           Thrust: [%.2f, %.2f, %.2f, %.2f] N\n', u_optimal');
%     end
end

% Final reference point
history_x_ref(:, N_sim + 1) = QuadrotorReferenceTrajectory6(T_sim);

% results.history_x = history_x;
% results.history_u = history_u;
% results.history_x_ref = history_x_ref;
% results.dt = dt;
% results.method = 'SingleShooting';
% save('sim_single.mat','results');


fprintf('Simulation completed!\n');
% fprintf('Rata-rata waktu solver: %.4f s, Maksimum: %.4f s\n', ...
%         mean(solver_times), max(solver_times));
%% Tracking Error
pos_error = history_x(1:3,:) - history_x_ref(1:3,:);   % error posisi
tracking_error = sqrt(sum(pos_error.^2,1));           % norm error tiap step
mean_tracking_error = mean(tracking_error);           % rata-rata error

%% Control Effort (energi)
control_effort = sum(sum(history_u.^2)) * dt;          % integral u^2

%% Smoothness (perubahan input)
du = diff(history_u,1,2);                              % delta u
smoothness = sum(sum(du.^2)) * dt;

fprintf('Mean tracking error = %.4f m\n', mean_tracking_error);
fprintf('Total control effort = %.4f\n', control_effort);
fprintf('Smoothness index = %.4f\n', smoothness);



% Plot results if function exists
if exist('PlotTrajectory', 'file') == 2
    PlotTrajectory;
else
    fprintf('PlotTrajectory function not found. Creating basic plots...\n');
end

%% Support Functions
function w_shifted = shift_solution(w_opt, nx, nu, N, M)
    % Versi minimal: otomatis ambil x_last dan u_last dari w_opt
    
    offset = 0;
    X_main = cell(N+1, 1);
    U_all = cell(N, 1);
    X_sub = cell(N, M-1);

    % Ambil X0
    X_main{1} = w_opt(offset+1 : offset+nx);
    offset = offset + nx;

    for k = 1:N
        U_all{k} = w_opt(offset+1 : offset+nu);
        offset = offset + nu;

        for m = 1:M-1
            X_sub{k,m} = w_opt(offset+1 : offset+nx);
            offset = offset + nx;
        end

        X_main{k+1} = w_opt(offset+1 : offset+nx);
        offset = offset + nx;
    end

    % Ambil tebakan terakhir otomatis
    x_last = X_main{end};
    u_last = U_all{end};

    % Bangun warm start
    w_shifted = [];
    w_shifted = [w_shifted; X_main{2}];

    for k = 2:N
        w_shifted = [w_shifted; U_all{k}];
        for m = 1:M-1
            w_shifted = [w_shifted; X_sub{k,m}];
        end
        w_shifted = [w_shifted; X_main{k+1}];
    end

    % Isi step terakhir
    w_shifted = [w_shifted; u_last];
    for m = 1:M-1
        w_shifted = [w_shifted; x_last];
    end
    w_shifted = [w_shifted; x_last];
end

function X_ref_horizon = generate_reference_horizon(t0, N, dt, ref_fun)
    nx = 12;
    X_ref_horizon = zeros(nx, N+1);
    for k = 0:N
        tk = t0 + k*dt;
        X_ref_horizon(:, k+1) = ref_fun(tk);
    end
end



function R_x = rotx(t)
    R_x = [1, 0, 0; 0, cos(t), -sin(t); 0, sin(t), cos(t)];
end

function R_y = roty(t)
    R_y = [cos(t), 0, sin(t); 0, 1, 0; -sin(t), 0, cos(t)];
end

function R_z = rotz(t)
    R_z = [cos(t), -sin(t), 0; sin(t), cos(t), 0; 0, 0, 1];
end