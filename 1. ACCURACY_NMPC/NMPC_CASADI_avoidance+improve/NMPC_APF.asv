% 1. Setup CasADi
% addpath('/home/zee/Erwin/MATLAB/casadi-3.7.1-linux64-matlab2018b');
addpath('C:\Users\DELL\Documents\MATLAB\casadi-3.7.0-windows64-matlab2018b');
import casadi.*

% Clear workspace to avoid variable conflicts
clear variables
clear x u
close all;
clc

%% 2. Definisikan Parameter Sistem
m = 0.5;    % Massa (kg)
g = 9.81;   % Gravitasi (m/s^2)
l = 0.25;   % Panjang lengan (m)
Ixx = 4.85e-3; % Momen inersia
Iyy = 4.85e-3;
Izz = 8.81e-3;

save_data = false;
improvement = true;
improvement_hybrid = true;
improvement_tc = false;
trajectory = 1;

%% ---------- APF parameters (set di awal, sebelum loop) ----------
k_att = 0.01;       % attractive gain
k_rep = 4.0;       % repulsive gain (tune)
d0    = 4.0;       % influence distance of obstacles [m]
v_scale = 0.1;     % scale factor to convert F_total -> v_ref (m/s per N-equivalent)
max_v_ref = 3.0;   % maximum lin velocity commanded by APF [m/s]
num_obs = 17;          % jumlah obstacle
z_pos = 1.0;          % tinggi referensi (anggap obstacle menempel ground, drone terbang di atas)
base_wx = 30;
base_wy = 30;
base_wz = 30;

% posisi obstacle (manual supaya jaraknya tidak terlalu dekat)
if trajectory == 1
    num_obs = 17; 
    obs_radius_val = 0.5;
    obs_center = [ 6  6  6  8   12   12   15   15   16   18   18   22  23   24  26  29   30 ;   % x
                   9  6  3  1.8  4   6.8   6   1.5  8.2  6.2  2.8  2   4.8  8   4   2.2  7.0 ;   % y
                   z_pos*ones(1,num_obs) ];       % z done
%     obs_center = [ 6  6  6  8   12   12   15   15   16   18   18   22  23   24  26  29   30 ;   % x
%                    9  5.5  3  1.8  4.5   5.5   5   1.5  8.2  6.2  2.8  2   4.8  8   4   2.2  7.0 ;   % y
%                    z_pos*ones(1,num_obs) ];       % z
%     obs_center = [ 6  9  6  8   12   12   15   15   16   18   18   22  23.5   24  26  29   30 ;   % x
%                        9  5.5  3  1.8  4   6   5   1.5  8.2  6.2  2.8  2   5  8   5   2.2  7.0 ;   % y
%                        z_pos*ones(1,num_obs) ];       % z done
%     obs_center = [ 6  6  6  8   12   12   15   15   16   18   18   22  23   24  30.5  30.5   30 ;   % x
%                    9  6  3  1.8  4   6.8   6   1.5  8.2  6.2  2.8  2   4.8  8   6.2   7.8  7.0 ;   % y
%                    z_pos*ones(1,num_obs) ];       % limitation

    obs_radius = obs_radius_val * ones(1,num_obs);
elseif trajectory == 2
    num_obs = 1;
    obs_radius_val = 0.5;
    obs_center = [20;10;z_pos*ones(1,num_obs) ];
    obs_radius = obs_radius_val * ones(1,num_obs);
else
    num_obs = 1.0; 
    obs_radius_val = 0.5;
    obs_center = [ 0.0;   % x
                   6.0;   % y
                   z_pos*ones(1,num_obs) ];       % z

    obs_radius = obs_radius_val * ones(1,num_obs);
end


% Pastikan semua parameter adalah scalar numeric
assert(isnumeric(m) && isscalar(m), 'Mass m must be numeric scalar');
assert(isnumeric(g) && isscalar(g), 'Gravity g must be numeric scalar');

% Dimensi State dan Input
nx = 12; % [x,y,z,phi,theta,psi,vx_inertial,vy_inertial,vz_inertial,p,q,r]
nu = 4;  % [f1, f2, f3, f4]

M = 1;
% Horizon Prediksi NMPC
N = 5; % Kurangi horizon untuk konvergensi lebih baik
dt = 0.1; % Time step lebih kecil
dt_sub = dt / M;  % pastikan M sudah didefinisikan

% Hovering thrust per motor (pastikan numeric)
thrust_hover_value = double(m * g / 4);  % Force as double
fprintf('Hover thrust per motor: %.3f N\n', thrust_hover_value);

%% 3. Definisikan Model Dinamika Quadrotor yang Konsisten
% Input simbolik
x = MX.sym('x', nx, 1); % State
u = MX.sym('u', nu, 1); % Input (gaya dorong motor)

% Ekstrak state
px = x(1); py = x(2); pz = x(3);
phi = x(4); theta = x(5); psi = x(6);
vx_inertial = x(7); vy_inertial = x(8); vz_inertial = x(9);
p = x(10); q = x(11); r = x(12);

% Konversi thrust motor ke total force dan torque
F_total = sum(u);
tau_phi = l * (u(2) - u(4));
tau_theta = l * (u(3) - u(1));
tau_psi = 0.005 * (-u(1) + u(2) - u(3) + u(4));

% Rotation matrices
R_b_i = rotz(psi) * roty(theta) * rotx(phi);

% Thrust dalam body frame (mengarah ke atas)
thrust_body = [0; 0; F_total];
% Transform ke inertial frame
thrust_inertial = R_b_i * thrust_body;

% Percepatan dalam inertial frame
ax_inertial = thrust_inertial(1) / m;
ay_inertial = thrust_inertial(2) / m;
az_inertial = thrust_inertial(3) / m - g;

% Persamaan Euler untuk angular acceleration
p_dot = (tau_phi + (Iyy - Izz) * q * r) / Ixx;
q_dot = (tau_theta + (Izz - Ixx) * p * r) / Iyy;
r_dot = (tau_psi + (Ixx - Iyy) * p * q) / Izz;

% Kinematic equations untuk orientasi
phi_dot = p + q*sin(phi)*tan(theta) + r*cos(phi)*tan(theta);
theta_dot = q*cos(phi) - r*sin(phi);
psi_dot = q*sin(phi)/cos(theta) + r*cos(phi)/cos(theta);

% State derivative
xdot = [vx_inertial; vy_inertial; vz_inertial; ... % Position rates
        phi_dot; theta_dot; psi_dot; ... % Orientation rates
        ax_inertial; ay_inertial; az_inertial; ... % Velocity rates (inertial)
        p_dot; q_dot; r_dot]; % Angular velocity rates

% Fungsi dinamika
f = Function('f', {x, u}, {xdot});

% Diskretisasi RK4
X = MX.sym('X', nx, 1);
U = MX.sym('U', nu, 1);
XDOT = f(X, U);
k1 = XDOT;
k2 = f(X + dt/2*k1, U);
k3 = f(X + dt/2*k2, U);
k4 = f(X + dt*k3, U);
X_next = X + dt/6*(k1 + 2*k2 + 2*k3 + k4);
F_discrete = Function('F_discrete', {X, U}, {X_next});

x_next_sub = X + dt_sub/6 * (k1 + 2*k2 + 2*k3 + k4);
F_sub = Function('F_sub', {X, U}, {x_next_sub});

%% 4. Setup NMPC Problem
w = {};
J = 0;
g = {};
lbw = []; ubw = []; w0 = [];
lbg = []; ubg = [];

X_vars = cell(N+1, 1);
U_vars = cell(N, 1);
X_sub_vars = cell(N, M-1);  % State intermediate dalam interval multiple shooting

% Parameter vector: [current_state; reference_state]
n_params = nx + nx*(N+1);  % [x0; xref_0; xref_1; ... xref_N]
all_params_sym = MX.sym('all_params', n_params, 1);
X_initial_param = all_params_sym(1:nx);
X_ref_param = all_params_sym(nx+1:end);  % Hasil MX, bukan cell
X_ref_params = cell(N+1, 1);
for k = 0:N
    start_idx = nx + nx*k + 1;
    end_idx = nx + nx*(k+1);
    X_ref_params{k+1} = all_params_sym(start_idx:end_idx);
end

% Initial state variable
X_vars{1} = MX.sym('X_0', nx, 1);
w = {w{:}, X_vars{1}};
lbw = [lbw; -inf*ones(nx,1)];
ubw = [ubw; inf*ones(nx,1)];
% w0 = [w0; zeros(nx,1)];

% Initial state constraint
g = {g{:}, X_vars{1} - X_initial_param};
lbg = [lbg; zeros(nx,1)];
ubg = [ubg; zeros(nx,1)];

% --- Generate warm start untuk propagasi awal ---
arg_w0 = [];
% x_guess = zeros(nx,1); 
x_guess = QuadrotorReferenceTrajectory6(0, trajectory);

% 1. Initial state
arg_w0 = [arg_w0; x_guess];

% 2. Loop sepanjang horizon
for k = 1:N
    % Control guess (hover)
    arg_w0 = [arg_w0; thrust_hover_value*ones(nu,1)];
    
    % Intermediate states (multiple shooting)
    for m = 1:M-1
        arg_w0 = [arg_w0; x_guess];  % bisa pakai interpolasi jika mau
    end
    
    % Next state guess
    arg_w0 = [arg_w0; x_guess];
end

F_total_norm_log = zeros(1, N); % Inisialisasi log
% Main horizon loop
for k = 0:N-1
    % Control variables
    U_vars{k+1} = MX.sym(['U_' num2str(k)], nu, 1);
    w = {w{:}, U_vars{k+1}};
    lbw = [lbw; 0.*thrust_hover_value*ones(nu,1)]; % Min 10% hover thrust
    ubw = [ubw; 2.0*thrust_hover_value*ones(nu,1)];   % Max 300% hover thrust
    arg_w0 = [arg_w0; thrust_hover_value*ones(nu,1)]; % Initialize at hover
    
    % Multiple Shooting Integration
    X_current = X_vars{k+1};
    for m = 1:M-1
        % Intermediate state
        X_sub_vars{k+1, m} = MX.sym(['X_' num2str(k) '_sub_' num2str(m)], nx, 1);
        w = {w{:}, X_sub_vars{k+1, m}};
        lbw = [lbw; -inf*ones(nx,1)];
        ubw = [ubw;  inf*ones(nx,1)];
        
        % Warm start dari propagasi dinamika
        x_guess = full(F_sub(x_guess, thrust_hover_value*ones(nu,1)));
        arg_w0 = [arg_w0; x_guess];
        
        % Constraint: integrasi sub-step
        X_predicted = F_sub(X_current, U_vars{k+1});
        g = {g{:}, X_predicted - X_sub_vars{k+1, m}};
        lbg = [lbg; zeros(nx,1)];
        ubg = [ubg; zeros(nx,1)];
        
        % Update state untuk sub-step berikutnya
        X_current = X_sub_vars{k+1, m};
    end
    
    % Next state variables
    X_vars{k+2} = MX.sym(['X_' num2str(k+1)], nx, 1);
    w = {w{:}, X_vars{k+2}};
    lbw = [lbw; -inf*ones(nx,1)];
    ubw = [ubw; inf*ones(nx,1)];
%     w0 = [w0; zeros(nx,1)];
    x_guess = full(F_discrete(x_guess, thrust_hover_value*ones(nu,1)));
    arg_w0 = [arg_w0; x_guess];
    
      % Constraint: integrasi akhir interval
    X_predicted_final = F_sub(X_current, U_vars{k+1});
    g = {g{:}, X_predicted_final - X_vars{k+2}};
    lbg = [lbg; zeros(nx,1)];
    ubg = [ubg; zeros(nx,1)];
    
    % Cost function - CONSERVATIVE tuning untuk stabilitas
    % Position tracking dengan weight yang reasonable
    Q = diag([10, 100, 150, ... % px, py, pz
                   1, 10, 10, ...   % phi, theta, psi
                   1, 1, 1, ...      % vx, vy, vz
                   1, 1, 1]);  % p, q, r
    R = diag([1, 1, 1, 1]); % Bobot upaya kontrol
    
    %% APF
    if improvement == true
        p = X_vars{k+1}(1:2); % posisi xy
        F_rep = MX.zeros(2,1);
        num_obs = size(obs_center,2);
        for j = 1:num_obs
            c = obs_center(1:2,j);
            r = obs_radius(j);
            vec = p - c;
            dist2 = vec' * vec;           % 1x1 MX
            dist  = sqrt(dist2 + 1e-12);  % scalar MX, +eps untuk stabilitas
            dist_surf = dist - r;
            dir_ = vec / (dist + 1e-6);   % 2x1 MX
            min_dist = min(inf, dist_surf);

                % Constraint: dist_surf >= d_safe  <=>  dist_surf - d_safe >= 0
            if improvement_hybrid == true
                g = {g{:}, dist_surf - 0.5};
                lbg = [lbg; 0];    % Batasan harus >= 0
                ubg = [ubg; inf];  % Tidak ada batas atas
            end

            mag = k_rep * (1./(dist_surf + 1e-6) - 1/d0) .* (1./((dist_surf + 1e-6).^2));

            F_rep = F_rep + if_else(dist_surf <= d0, mag * dir_, MX.zeros(2,1));
        end


        p = X_vars{k+1}(1:2);        % posisi drone saat ini
        p_goal = X_ref_params{k+1}(1:2);  % posisi goal
        F_att = - k_att * (p - p_goal);  % 2x1 vector MX
 
        %%
        J = J + (X_vars{k+1} - X_ref_params{k+1})' * Q * (X_vars{k+1} - X_ref_params{k+1}) + ...
                U_vars{k+1}' * R * U_vars{k+1} + ...
                (F_att' * F_att) + (F_rep' * F_rep);  
    else
        J = J + (X_vars{k+1} - X_ref_params{k+1})' * Q * (X_vars{k+1} - X_ref_params{k+1}) + ...
                U_vars{k+1}' * R * U_vars{k+1};
    end
      
    for m = 1:M-1
        Q_sub = 0.1 * Q;
        alpha = m / M;
        X_ref_interp = (1-alpha) * X_ref_params{k+1} + alpha * X_ref_params{k+2};
        J = J + (X_sub_vars{k+1, m} - X_ref_interp)' * Q_sub * (X_sub_vars{k+1, m} - X_ref_interp);
    end
    
    % Input rate penalty
    if k > 0
        if improvement_tc == false
            R_rate = 0.1 * eye(nu);
        else
            tracking_error = norm(X_vars{k+1}(1:3) - X_ref_params{k+1}(1:3)); % error posisi (x,y,z)
            adapt_factor = 1 + tracking_error;  % semakin besar error, semakin longgar
            R_rate = (1 / adapt_factor) * eye(nu);
%         R_rate = rate_penalty_param * eye(nu);
        end

        J = J + (U_vars{k+1} - U_vars{k})' * R_rate * (U_vars{k+1} - U_vars{k});
    end

end

% Terminal cost
if improvement_tc == true
    adapt_factor = 1 + exp(-min_dist);
    pos_weight_x = base_wx * adapt_factor;
    pos_weight_y = base_wy * adapt_factor;
    pos_weight_z = base_wz * adapt_factor;

    Qf = diag([pos_weight_x, pos_weight_y, pos_weight_z, zeros(1,nx-3)]);
else
    Qf = 100 * Q; % Higher terminal weight
end
J = J + (X_vars{N+1} - X_ref_params{N+1})' * Qf * (X_vars{N+1} - X_ref_params{N+1});


% NLP problem
nlp = struct('f', J, 'x', vertcat(w{:}), 'g', vertcat(g{:}), 'p', all_params_sym);

% Solver options - lebih konservatif untuk stabilitas
solver_options = struct;
solver_options.print_time = false;
solver_options.ipopt.max_iter = 5;
solver_options.ipopt.tol = 1e-2;
solver_options.ipopt.acceptable_tol = 1e-1;
solver_options.ipopt.linear_solver = 'mumps';
solver_options.ipopt.hessian_approximation = 'exact';
solver_options.ipopt.print_level = 0;
solver_options.ipopt.mu_strategy = 'adaptive';

solver = nlpsol('solver', 'ipopt', nlp, solver_options);
% solver.generate('nmpc_solver.c');
% mex nmpc_solver.c -largeArrayDims -lipopt -lmumps

%% 5. Simulation Loop
T_sim = 20;
N_sim = T_sim / dt;
history_x = zeros(nx, N_sim + 1);
history_u = zeros(nu, N_sim);
history_x_ref = zeros(nx, N_sim + 1);
v_ref_history = zeros(2,N_sim);

% Initial state: start closer to first reference point
x_ref_initial = QuadrotorReferenceTrajectory6(0, trajectory);
current_state = zeros(nx, 1);
current_state(1:3) = x_ref_initial(1:3); % Start at reference position
current_state(3) = max(current_state(3), 0.0); % Ensure minimum altitude
history_x(:, 1) = current_state;


%%
fprintf('Starting NMPC simulation...\n');
fprintf('Initial state: [%.3f, %.3f, %.3f]\n', current_state(1:3)');

for i = 1:N_sim
    
    current_time = (i-1) * dt;
    % Get reference trajectory
    x_ref_at_current_time = QuadrotorReferenceTrajectory6(current_time, trajectory);
    history_x_ref(:, i) = x_ref_at_current_time;
    
    %%APF
    if improvement == false
        p = current_state(1:2);  % drone position
        F_att = -k_att/2*(p - x_ref_at_current_time(1:2));
        F_rep = zeros(2,1);
        num_obs = size(obs_center,2);
        for j = 1:num_obs
            c = obs_center(1:2,j);
            r = obs_radius(j);
            vec = p - c;
            dist = norm(vec);
            d = dist - r;  % distance to obstacle surface
            if d <= 0
                % already inside obstacle -> strong repulsion (clamp to avoid NaN)
                dir_ = vec / (dist + 1e-6);
                F_rep = F_rep + k_rep * 1e3 * dir_;
                status = '!!! MENABRAK !!!';
            elseif d < d0
                dir_ = vec / dist;
                % standard repulsive magnitude
                if improvement == true
                    mag = k_rep/d^2*(1/d - 1/d0)^2*(d0/norm(d))^2;
                else
                    mag = k_rep*(1/d - 1/d0)^2;
                end
                F_rep = F_rep + mag * dir_;
                status = 'Dekat (zona repulsif)';
            else
                status = 'Aman (di luar zona repulsif)';
            end
            fprintf('Waktu %.2f s | Obstacle %d | Jarak permukaan d = %.2f m | Status: %s\n', ...
            i*dt, j, d, status);
        end
        F_total = F_att + F_rep;

        v_ref_local = v_scale * F_total;
        % limit magnitude
        vn = norm(v_ref_local);
        if vn > max_v_ref
            v_ref_local = v_ref_local / vn * max_v_ref;
        end
        % optionally smooth v_ref over time (low-pass)
        if exist('prev_v_ref','var')
            alpha_lp = 0.3; % low-pass factor (0..1), tune
            v_ref = alpha_lp * prev_v_ref + (1-alpha_lp) * v_ref_local;
        else
            v_ref = v_ref_local;
        end
        X_ref_horizon = generate_reference_horizon(current_time, N, dt, @QuadrotorReferenceTrajectory6, trajectory);
        for kk = 1:(N+1)
            % shift only the position rows (1:3)
            % optionally reduce shift weighting for farther horizon steps (fade-out)
            weight = exp(-0.1*(kk-1)); 
            X_ref_horizon(1:2,kk) = X_ref_horizon(1:2,kk) + weight * v_ref * (kk-1)*dt;
        end

    
    %%
    % Build parameter vector
    else
        X_ref_horizon = generate_reference_horizon(current_time, N, dt, @QuadrotorReferenceTrajectory6, trajectory);
%         T_safety_start = 0.0;
%         P_goal = [33; 7; 5]; % Tujuan Akhir
%         V_MAX = 10.0; 
%         V_MIN_RECOVERY = 1.0; 
%         T_STABLE_MIN = 2.0; 
%         state_machine = 1;      % 1 = STATE_MISSION (Initial state)
% 
%         % --- Di Dalam Main Loop Simulasi (setiap langkah waktu) ---
% 
%         % 1. Dapatkan Reference Horizon Adaptif
%         [X_ref_horizon, state_machine] = get_adaptive_reference( ...
%             current_time, current_state, state_machine, N, dt, P_goal, ...
%         V_MAX, V_MIN_RECOVERY, T_STABLE_MIN, T_safety_start, @QuadrotorReferenceTrajectory6, trajectory);
    end
        actual_params = [current_state; reshape(X_ref_horizon, [], 1)];
    % Solve NMPC
    try
%         tic;
        sol = solver('x0', arg_w0, 'lbx', lbw, 'ubx', ubw, ...
                     'lbg', lbg, 'ubg', ubg, 'p', actual_params);
%         solver_time = toc; % catat waktu solver
%         fprintf('Step %d: Solver time = %.4f s (dt = %.4f s)\n', i, solver_time, dt);
%         solver_times(i) = solver_time;
        
        % Extract optimal control
        opt_w = full(sol.x);
        u_optimal = opt_w(nx + 1 : nx + nu);
        
        % Check solver status (compatible with different CasADi versions)
        try
            if isfield(sol, 'stats') && isfield(sol.stats, 'return_status')
                status = char(sol.stats.return_status);
                if ~strcmp(status, 'Solve_Succeeded')
                    fprintf('Warning: Solver status at step %d: %s\n', i, status);
                end
            end
        catch
            % Ignore status check if not available
        end
        
    catch ME
        fprintf('Solver failed at step %d: %s\n', i, ME.message);
        % Use hover thrust as fallback
        u_optimal = thrust_hover_value * ones(nu, 1);
        opt_w = arg_w0; % Keep previous solution for warm start
    end
    
    history_u(:, i) = u_optimal;
    
    % Simulate system forward
    current_state = full(F_discrete(current_state, u_optimal));
    history_x(:, i+1) = current_state;
    
    % Update warm start
    arg_w0 = shift_solution(opt_w, nx, nu, N, M);
    
    % Dapatkan kecepatan dari trajektori asli untuk perbandingan
    v_ref_original = x_ref_at_current_time(7:9);
    vn_original = norm(v_ref_original);
    % Dapatkan kecepatan aktual dari history simulasi
    vel_nmpc_actual = history_x(7:9, i);
    vn_nmpc_actual = norm(vel_nmpc_actual);

    fprintf('Waktu %.2f s | Kecepatan aktual (NMPC): %.2f\n\n',...
        i*dt, vn_nmpc_actual);
end

% Final reference point
history_x_ref(:, N_sim + 1) = QuadrotorReferenceTrajectory6(T_sim, trajectory);

if save_data == true
%     if improvement == true && improvement_hybrid == true
    if improvement == true && improvement_hybrid == true && improvement_tc == true
        results.history_x = history_x;
        results.history_u = history_u;
        results.history_x_ref = history_x_ref;
        results.dt = dt;
        results.method = 'SingleShooting';
        save('sim_single.mat','results');
%     elseif improvement == true && improvement_hybrid == false
    elseif improvement == true && improvement_hybrid == true && improvement_tc == false
        results.history_x = history_x;
        results.history_u = history_u;
        results.history_x_ref = history_x_ref;
        results.dt = dt;
        results.method = 'MultiShooting';
        save('sim_multi.mat','results');
    else
        results.history_x = history_x;
        results.history_u = history_u;
        results.history_x_ref = history_x_ref;
        results.dt = dt;
        results.method = 'MultiShooting3';
        save('sim_multi3.mat','results');
    end
end

fprintf('Simulation completed!\n');
% fprintf('Rata-rata waktu solver: %.4f s, Maksimum: %.4f s\n', ...
%         mean(solver_times), max(solver_times));
%% Tracking Error
pos_error = history_x(1:3,:) - history_x_ref(1:3,:);   % error posisi
tracking_error = sqrt(sum(pos_error.^2,1));           % norm error tiap step
mean_tracking_error = mean(tracking_error);           % rata-rata error

%% Control Effort (energi)
control_effort = sum(sum(history_u.^2)) * dt;          % integral u^2

%% Smoothness (perubahan input)
du = diff(history_u,1,2);                              % delta u
smoothness = sum(sum(du.^2)) * dt;

fprintf('Mean tracking error = %.4f m\n', mean_tracking_error);
fprintf('Total control effort = %.4f\n', control_effort);
fprintf('Smoothness index = %.4f\n', smoothness);



% Plot results if function exists
if exist('PlotTrajectory', 'file') == 2
    PlotTrajectory;
else
    fprintf('PlotTrajectory function not found. Creating basic plots...\n');
end

%% Support Functions
function w_shifted = shift_solution(w_opt, nx, nu, N, M)
    % Versi minimal: otomatis ambil x_last dan u_last dari w_opt
    
    offset = 0;
    X_main = cell(N+1, 1);
    U_all = cell(N, 1);
    X_sub = cell(N, M-1);

    % Ambil X0
    X_main{1} = w_opt(offset+1 : offset+nx);
    offset = offset + nx;

    for k = 1:N
        U_all{k} = w_opt(offset+1 : offset+nu);
        offset = offset + nu;

        for m = 1:M-1
            X_sub{k,m} = w_opt(offset+1 : offset+nx);
            offset = offset + nx;
        end

        X_main{k+1} = w_opt(offset+1 : offset+nx);
        offset = offset + nx;
    end

    % Ambil tebakan terakhir otomatis
    x_last = X_main{end};
    u_last = U_all{end};

    % Bangun warm start
    w_shifted = [];
    w_shifted = [w_shifted; X_main{2}];

    for k = 2:N
        w_shifted = [w_shifted; U_all{k}];
        for m = 1:M-1
            w_shifted = [w_shifted; X_sub{k,m}];
        end
        w_shifted = [w_shifted; X_main{k+1}];
    end

    % Isi step terakhir
    w_shifted = [w_shifted; u_last];
    for m = 1:M-1
        w_shifted = [w_shifted; x_last];
    end
    w_shifted = [w_shifted; x_last];
end

function X_ref_horizon = generate_reference_horizon(t0, N, dt, ref_fun, trajectory)
    nx = 12;
    X_ref_horizon = zeros(nx, N+1);
    for k = 0:N
        tk = t0 + k*dt;
        X_ref_horizon(:, k+1) = ref_fun(tk,trajectory);
    end
end



function R_x = rotx(t)
    R_x = [1, 0, 0; 0, cos(t), -sin(t); 0, sin(t), cos(t)];
end

function R_y = roty(t)
    R_y = [cos(t), 0, sin(t); 0, 1, 0; -sin(t), 0, cos(t)];
end

function R_z = rotz(t)
    R_z = [cos(t), -sin(t), 0; sin(t), cos(t), 0; 0, 0, 1];
end

function [X_ref_horizon, state_machine] = get_adaptive_reference(current_time, current_state, state_machine_in, N, dt_NMPC, P_goal, V_MAX, V_MIN_RECOVERY, T_STABLE_MIN, T_safety_start_in, generate_ref_fcn, trajectory)
% [INPUTS]:
%   current_time: Waktu simulasi saat ini.
%   current_state: Vektor status drone saat ini (X).
%   state_machine_in: Status mode dari langkah waktu sebelumnya.
%   N, dt_NMPC: Horizon dan langkah waktu NMPC.
%   P_goal: Posisi tujuan akhir.
%   V_MAX, V_MIN_RECOVERY, T_STABLE_MIN: Konstanta trigger.
%   T_safety_start_in: Waktu saat Safety Mode dimulai (dari langkah sebelumnya).
%   generate_ref_fcn: Handle fungsi referensi awal (misal, @QuadrotorReferenceTrajectory6).
%   trajectory: Data trajectory awal (jika ada).

% [OUTPUTS]:
%   X_ref_horizon: Horizon referensi [12 x N].
%   state_machine: Status mode yang diperbarui.

    % --- Definisikan Konstanta Mode ---
    STATE_MISSION = 1;
    STATE_PLANNING_NEW_PATH =2;
    STATE_SAFETY_BRAKE = 3;
    V_WARNING = 6.0; 
%     STATE_RECOVERY_CALC = 3;
    
    % Inisialisasi/Ambil Status
    state_machine = state_machine_in;
    T_safety_start = T_safety_start_in;
    
    % Dapatkan Kecepatan dan Posisi Aktual
    v_actual = norm(current_state(7:9)); % Asumsi status 7,8,9 adalah vx, vy, vz
    P_actual = current_state(1:3);      % Posisi saat ini [x; y; z]
    
    % --- LOGIKA TRANSISI MODE ---
    
    if state_machine == STATE_MISSION
        if v_actual > V_WARNING
        state_machine = STATE_PLANNING_NEW_PATH;
        disp(['[WARNING] V_actual (', num2str(v_actual, '%.2f'), ' m/s) > V_WARNING. Merencanakan jalur baru.']);
        
    % --- TRANSISI DARURAT (Jika Peringatan Terlambat) ---
        elseif v_actual > V_MAX % V_MAX > V_WARNING
            state_machine = STATE_SAFETY_BRAKE;
            T_safety_start = current_time;
            disp(['[EMERGENCY] V_actual (', num2str(v_actual, '%.2f'), ' m/s) > V_MAX. SAFETY BRAKE.']);
        end
        
    elseif state_machine == STATE_SAFETY_BRAKE
        if v_actual < V_MIN_RECOVERY && (current_time - T_safety_start) >= T_STABLE_MIN
            state_machine = STATE_RECOVERY_CALC;
            disp('[RECOVERY] Drone stabil. Menghitung jalur baru.');
        end
    end
    
    % --- GENERASI REFERENCE BERDASARKAN MODE ---
    
    if state_machine == STATE_MISSION
        % Mode 1: Jalur Lurus Normal / Tracking Jalur Baru
        X_ref_horizon = generate_reference_horizon(current_time, N, dt_NMPC, generate_ref_fcn, trajectory);
        
    elseif state_machine == STATE_SAFETY_BRAKE
        % Mode 2: Safety/Brake Mode (Hover di tempat)
        X_ref_horizon = zeros(12, N+1); 
        for k = 1:N
            X_ref_horizon(1:3, k) = P_actual; % Posisi target = P_actual
        end
        
    elseif state_machine == STATE_PLANNING_NEW_PATH
        % Mode 3: Hitung Jalur Baru (Re-Targeted)
        T_path_duration = 15; % Durasi jalur pemulihan (misal, 15 detik)
        X_ref_new_full = generate_spline_trajectory(P_actual, P_goal, T_path_duration); % <-- Panggil fungsi spline
        
        % Atur kembali ke Mode Misi setelah jalur dihitung
        state_machine = STATE_MISSION; 
        
        % Inisialisasi Goal State Penuh (12x1)
        X_goal_state = zeros(12, 1);
        X_goal_state(1:3) = P_goal; % Posisi X, Y, Z disetel ke P_goal

        % Ambil horizon yang dibutuhkan dari jalur baru
        N_ref_full = size(X_ref_new_full, 2);
        
        if N_ref_full >= N
             % Jika jalur baru cukup panjang, ambil N kolom pertama
             X_ref_horizon = X_ref_new_full(:, 1:N);
        else
             % JIKA JALUR TERLALU PENDEK (Solusi Perbaikan Kesalahan Repmat)
             
             % 1. Hitung jumlah kolom sisa yang harus diisi
             num_cols_to_fill = N - N_ref_full; 
             
             % 2. Buat matriks penambal (Padding Matrix) dari Goal State
             % Replikasi X_goal_state (12x1) sebanyak num_cols_to_fill (misal 1 kolom)
             X_padding = repmat(X_goal_state, 1, num_cols_to_fill); 
             
             % 3. Gabungkan jalur spline dengan penambal
             X_ref_horizon = [X_ref_new_full, X_padding];
        end
    end
end

function X_ref_full = generate_spline_trajectory(P_start, P_end, T_duration)
    % P_start, P_end: [x; y; z] (Posisi Mulai dan Akhir)
    % T_duration: Total waktu yang dialokasikan untuk jalur baru (misal, 10-20 detik)
    
    dt_ref = 0.1; % Resolusi waktu referensi
    time_vec = 0:dt_ref:T_duration;
    N_full = length(time_vec);
    
    % Asumsikan 12 Status (X)
    X_ref_full = zeros(12, N_full); 

    % Definisikan Kondisi Batas (Boundary Conditions)
    % Drone Start di P_start dengan Kecepatan Nol (V_start = 0, A_start = 0)
    % Drone End di P_end dengan Kecepatan Nol (V_end = 0, A_end = 0)
    
    t_f = T_duration;
    
    % Loop untuk setiap dimensi (X, Y, Z)
    for dim = 1:3 
        p_start = P_start(dim);
        p_end = P_end(dim);
        
        % Koefisien Polinomial Kuintik (ax^5 + bx^4 + cx^3 + dx^2 + ex + f)
        % Di sini, kita menggunakan V_start=0, A_start=0, V_end=0, A_end=0
        
        % Rumus Sederhana untuk Polinomial Kuintik (jika V=A=0 di awal dan akhir)
        a = 6 * (p_start - p_end) / (t_f^5);
        b = -15 * (p_start - p_end) / (t_f^4);
        c = 10 * (p_start - p_end) / (t_f^3);
        d = 0; % Awal Kecepatan Nol
        e = 0; % Awal Akselerasi Nol
        f = p_start;
        
        for k = 1:N_full
            t = time_vec(k);
            
            % Posisi
            p_t = a*t^5 + b*t^4 + c*t^3 + d*t^2 + e*t + f;
            % Kecepatan
            v_t = 5*a*t^4 + 4*b*t^3 + 3*c*t^2 + 2*d*t + e;
            % Akselerasi
            a_t = 20*a*t^3 + 12*b*t^2 + 6*c*t + 2*d;
            
            % Simpan ke Referensi
            X_ref_full(dim, k) = p_t;
            X_ref_full(dim + 6, k) = v_t; % Vektor status 7, 8, 9 adalah kecepatan
        end
    end
    % Asumsi status lain (sudut, kecepatan sudut) adalah 0 atau default
end
